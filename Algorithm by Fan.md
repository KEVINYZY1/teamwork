# 三个算法
### GC 标记-清除算法

由标记和清除两个阶段构成。

**标记阶段**标记所有活动对象。从根直接引用的对象开始，利用深度（广度）优先算法递归地标记所有指针数组能访问到的对象。为了降低内存使用率，通常使用深度优先算法。

**清除阶段**清楚所有未标记的非活动对象。清除阶段从堆的起点开始，遍历整个堆，回收未被标记的对象，将已被标记的对象的标记抹去。

回收好的空间可以重新进行分配。包括First Fit、Best Fit、Worst Fit。分配完的小分块如果是连续的，可以合并成较大的一个。

**优点**：实现简单，不移动对象，与保守GC算法兼容。  

**缺点**：分配时产生空间碎片，遍历链表导致分配速度慢，与写时复制技术（进程内存共享）不兼容。

#### 对策：

**分配速度慢**：创建多个空闲链表——长度为1字节的空间、长度为2字节的空间.......长度大于100字节的空间（通常很少申请较大空间的分块）

**碎片化**：BiBOP法，即把堆分割成固定大小的块，特定大小的对象只能由同样大小的块分配空间。但这样可能导致很多同样大小的空间未被利用，未彻底解决碎片化问题。

**不兼容写时复制**：位图标记法，标记的位处于对象的头，使得更改标记位（即使不重写对象）也需要复制共享内存的数据，冗余复制过多。为此我们单独为标志位制作一张表格（每个字分配一位），标记是对表格进行操作。由于所有对象的位集中在一起，可以快速消除标志位。

**清除花费时间过多**：延迟清除法，即如果能用清除操作分配空间，则返回分块，否则先标记，再调用延迟清除函数进行分配。



### 引用计数法

每个对象拥有一个计数器，记录有多少个对象引用了自己。

计数器在以下情况进行改变：①新创建一个对象，该对象的计数器重置为一  ②当一个指针新指向一个对象的时候，它原来指向的对象计数器减一（为零时回收该对象，该对象引用的所有子对象引用减一），新指向的对象计数器加一。

**优点**：垃圾可以立刻回收，最大暂停时间短，不需要沿指针查找。

**缺点**：处理计数器增减开销过大，计数器占用空间较多，实现较为复杂，无法回收循环引用的对象。

#### 改良：

**延迟引用计数**：处理计数器增减开销过大，很大一部分原因是根引用变化频繁。为此，根引用的对象变化不改变计数器，为了防止活动对象被回收，计数器为0的对象暂存在一个表里，需要释放内存时，扫描该表，将其中根引用的对象计数器加一，回收剩余计数器为0的对象。但这毁坏了立刻回收的性质，也加大了最大暂停时间。

**Sticky引用计数法**：主要是为了解决计数器占位太多的问题。实际由很多对象刚被创建就死亡，不必留太多位给计数器，计数器溢出的对象很少（这部分对象我们不做处理）。此外，还可以将标记-清除算法与引用计数法结合，标记阶段对计数器进行增量操作，清除阶段回收计数器为0的对象。它能回收计数器溢出的对象和循环的垃圾。

**1位引用计数法**：Sticky引用计数法的极端情况（观察发现几乎所有对象是不共有的），只留一位（可以称为标签）给计数器，计数器由指针持有。0代表只有1次引用，1代表有多次引用。指针操作仅有复制和删除（释放标签为0的指针所指的对象），这使得高速缓存不容易缺失。这种方法难点在于处理溢出的对象。

**部分标记-清除算法**：为了处理循环垃圾。只对有可能循环引用的垃圾使用标记-清除算法，其他对象使用引用计数法。对象有四种标记：绝对不是垃圾、绝对是垃圾、搜索完毕、可能是循环垃圾。通过遍历可能是循环垃圾的对象，递归访问其子对象，使其计数器减一，将最终计数器为0的对象（循环垃圾）回收，实现了对循环垃圾的处理。缺点在于遍历代价太高，极大延长了最大暂停时间。